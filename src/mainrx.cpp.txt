//ini main code
// ===== LoRa Receiver (Enhanced) =====
#include <SPI.h>
#include <LoRa.h>
#include <WiFi.h>
#include <HTTPClient.h>
// #include <PubSubClient.h>
#ifndef LORA_NSS_PIN
  #define LORA_NSS_PIN LORA_SS   // or replace with `ss` if that‚Äôs your symbol
#endif
// ------------ Config ------------
#define LORA_SS    5
#define LORA_RST   13
#define LORA_DIO0  25
#define LORA_FREQ  923E6
#define LORA_SYNC  0x34

#define DEBUG 1
#if DEBUG
  #define DBG(...)  Serial.println(__VA_ARGS__)
#else
  #define DBG(...)
#endif

// If your sender uses packed structs, match packing:
#pragma pack(push,1)
struct LoRaData {
  uint32_t deviceID;
  uint8_t  packetCounter;
  double   latitude;
  double   longitude;
  float    altitude;
  float    speed;
  uint8_t  satellites;
  char     timeUTC[20];  // enough for "YYYY/MM/DD,HH:MM:SS" + '\0'
  bool     doorValue;
};
#pragma pack(pop)


LoRaData receivedData;

const char* WIFI_SSID = "alyaone";
const char* WIFI_PASS = "apayalupa";

// InfluxDB v2
const char* INFLUX_URL = "http://172.20.10.5:8086";
const char* INFLUX_ORG    = "my-org";
const char* INFLUX_BUCKET = "smart-ecoport";
const char* INFLUX_TOKEN  = "my-super-token";

static void connectWiFi() {
  if (WiFi.status() == WL_CONNECTED) return;
  WiFi.mode(WIFI_STA);
  WiFi.setSleep(false);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  uint32_t t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 15000) {
    delay(300); Serial.print('.');
  }
  Serial.println(WiFi.status()==WL_CONNECTED ? "\nWiFi OK" : "\nWiFi FAIL");
    if (WiFi.status() == WL_CONNECTED) {
    Serial.print("ESP32 IP: ");
    Serial.println(WiFi.localIP());
  }

}

static bool writeToInfluxDB(const String& lineProtocol) {
  if (WiFi.status() != WL_CONNECTED) return false;
  String url = String(INFLUX_URL) + "/api/v2/write?org=" + INFLUX_ORG +
               "&bucket=" + INFLUX_BUCKET + "&precision=ms";
  HTTPClient http;
  http.begin(url);
  http.setTimeout(10000);
  http.setReuse(false);
  http.addHeader("Connection","close");
  // http.useHTTP10(true); // aktifkan bila koneksi kadang hang / proxy rewel

  http.addHeader("Content-Type", "text/plain; charset=utf-8");
  http.addHeader("Authorization", String("Token ") + INFLUX_TOKEN);
  int code = http.POST(lineProtocol);
  bool ok = (code >= 200 && code < 300);
  if (!ok) { Serial.printf("Influx ERR %d: %s\n", code, http.getString().c_str()); }
  http.end();
  return ok;
}


// ------------ Helpers ------------
static void hexDump(const uint8_t* buf, int len) {
  for (int i = 0; i < len; ++i) {
    if (i % 16 == 0) Serial.println();
    if (buf[i] < 16) Serial.print('0');
    Serial.print(buf[i], HEX);
    Serial.print(' ');
  }
  Serial.println();
}
static uint8_t sx127xReadReg(uint8_t addr) {
  SPI.beginTransaction(SPISettings(8000000, MSBFIRST, SPI_MODE0));
  digitalWrite(LORA_NSS_PIN, LOW);
  SPI.transfer(addr & 0x7F);
  uint8_t v = SPI.transfer(0x00);
  digitalWrite(LORA_NSS_PIN, HIGH);
  SPI.endTransaction();
  return v;
}

static void sx127xWriteReg(uint8_t addr, uint8_t val) {
  SPI.beginTransaction(SPISettings(8000000, MSBFIRST, SPI_MODE0));
  digitalWrite(LORA_NSS_PIN, LOW);
  SPI.transfer(addr | 0x80);
  SPI.transfer(val);
  digitalWrite(LORA_NSS_PIN, HIGH);
  SPI.endTransaction();
}

static void loraSetLDRO(bool on) {               // RegModemConfig3 bit3
  uint8_t r = sx127xReadReg(0x26);
  r = on ? (r |  0b00001000) : (r & ~0b00001000);
  sx127xWriteReg(0x26, r);
}

static void loraSetLnaBoostHF(bool on) {         // RegLna bits7:6 = 11
  uint8_t r = sx127xReadReg(0x0C) & 0x3F;
  if (on) r |= 0xC0;
  sx127xWriteReg(0x0C, r);
}

void setup() {
  Serial.begin(115200);
  delay(300);
  Serial.println("\nüì° LoRa Receiver Node Starting...");

  LoRa.setPins(LORA_SS, LORA_RST, LORA_DIO0);

  int tries = 0;
  while (!LoRa.begin(LORA_FREQ)) {
    Serial.println("LoRa init failed. Retrying...");
    delay(400);
    if (++tries > 20) {
      Serial.println("LoRa init giving up. Check wiring/freq.");
      return; // bail out if radio never comes up
    }
  }

  // ---- Match the transmitter‚Äôs settings ----
  // validate packets with CRC

  LoRa.setSpreadingFactor(12);     // SF7..12 (higher = longer range, lower data rate)
  LoRa.setSignalBandwidth(125E3); // 7.8k..500k (narrower = better sensitivity, lower data rate)
  LoRa.setCodingRate4(8);         // 4/5..4/8 (higher = more robust, lower throughput)
  LoRa.setPreambleLength(12);      // default is 8, can increase for noisy links
  LoRa.setSyncWord(0x34);         // must match RX
  LoRa.enableCrc();               // must match RX
  LoRa.setGain(0);                // 0 = AGC ON (auto LNA gain control)
  loraSetLDRO(true);              // LDRO ON (needed for SF11/SF12 at narrow BW)
  loraSetLnaBoostHF(true);        // LNA Boost HF ON (extra sensitivity, more current)


  // Optional RX-side tuning (leave as-is if unsure):
  // LoRa.setGain(0);                   // 0 = AGC (default). 1..6 = manual LNA gain.

  Serial.println("LoRa Initialized OK!");
  Serial.println("Ready to receive packets.");

  // If you use onReceive(callback), enable continuous RX:
  // LoRa.onReceive(onLoRaPacket);
  // LoRa.receive();

  // Otherwise, if you poll with LoRa.parsePacket() in loop(), no extra call needed.
  connectWiFi();
}


void loop() {
  // if (!client.connected()) { /* reconnect MQTT */ }
  // client.loop();

  int packetSize = LoRa.parsePacket();
  if (!packetSize) {
    delay(2);
    return;
  }

  // Show basic RF stats
  int rssi = LoRa.packetRssi();
  float snr = LoRa.packetSnr();
  Serial.println("\n‚úÖ LoRa packet detected.");
  Serial.print("Packet bytes: "); Serial.println(packetSize);
  Serial.print("RSSI: "); Serial.print(rssi);
  Serial.print(" dBm | SNR: "); Serial.print(snr, 1); Serial.println(" dB");

  // If size matches our struct, read directly; else show hex dump
  if (packetSize == (int)sizeof(LoRaData)) {
    memset(&receivedData, 0, sizeof(receivedData)); // avoid stale bytes
    int n = LoRa.readBytes((uint8_t*)&receivedData, sizeof(receivedData));
    // Drain any leftover (should be none if sizes match)
    while (LoRa.available()) LoRa.read();

    if (n == sizeof(LoRaData)) {
      // Ensure C-string termination (defensive)
      receivedData.timeUTC[sizeof(receivedData.timeUTC) - 1] = '\0';

      Serial.print("\n------ Receive Data Packet #");
      Serial.print(receivedData.packetCounter);
      Serial.println(" ------");
      Serial.print("Add: "); Serial.println(receivedData.deviceID);
      Serial.print("Lat: ");  Serial.println(receivedData.latitude, 6);
      Serial.print("Lon: ");  Serial.println(receivedData.longitude, 6);
      Serial.print("Alt: ");  Serial.print(receivedData.altitude, 2); Serial.println(" m");
      Serial.print("Spd: ");  Serial.print(receivedData.speed, 2);    Serial.println(" km/h");
      Serial.print("Sats: "); Serial.println(receivedData.satellites);
      Serial.print("Time: "); Serial.println(receivedData.timeUTC);
      Serial.print("Door: "); Serial.println(receivedData.doorValue ? "Switch Closed" : "Switch Open");

      Serial.println("---------------------------------------------");

        // ---- Build JSON (untuk debugging / subsystems lain) ----
String json = "{";
  json += "\"deviceID\":" + String(receivedData.deviceID) + ",";
  json += "\"packetCounter\":" + String(receivedData.packetCounter) + ",";
  json += "\"rssi\":" + String(rssi) + ",";
  json += "\"snr\":" + String(snr,1) + ",";
  json += "\"door\":" + String(receivedData.doorValue ? "true" : "false") + ",";
  json += "\"gps\":{";
    json += "\"lat\":" + String(receivedData.latitude, 6) + ",";
    json += "\"lon\":" + String(receivedData.longitude, 6) + ",";
    json += "\"alt\":" + String(receivedData.altitude, 2) + ",";
    json += "\"speed\":" + String(receivedData.speed, 2) + ",";
    json += "\"sats\":" + String((int)receivedData.satellites) + ",";
    json += "\"timeUTC\":\"" + String(receivedData.timeUTC) + "\"";
  json += "}";
json += "}";
Serial.println("JSON:");
Serial.println(json);

// ---- InfluxDB line protocol (telemetry) ----
String lp; lp.reserve(256);
lp  = "telemetry";
lp += ",device="; lp += String(receivedData.deviceID);
lp += " ";
lp += "packetCounter="; lp += String((int)receivedData.packetCounter); lp += "i,";
lp += "rssi=";          lp += String((int)rssi); lp += "i,";
lp += "snr=";           lp += String(snr,1); lp += ",";
lp += "door=";          lp += (receivedData.doorValue ? "true" : "false"); lp += ",";
lp += "lat=";           lp += String(receivedData.latitude, 6); lp += ",";
lp += "lon=";           lp += String(receivedData.longitude, 6); lp += ",";
lp += "alt=";           lp += String(receivedData.altitude, 2); lp += ",";
lp += "speed=";         lp += String(receivedData.speed, 2); lp += ",";
lp += "sats=";          lp += String((int)receivedData.satellites); lp += "i";

if (!writeToInfluxDB(lp)) {
  Serial.println("‚ùå Influx write failed");
} else {
  Serial.println("‚úÖ Influx write OK");
}
    } else {
      Serial.println("Error: struct read incomplete. Dumping raw:");
      // read any remaining bytes (already drained above) then print what we got
      hexDump((const uint8_t*)&receivedData, n);
    }

  } else {
    // Unexpected length ‚Äî read and hexdump for debugging
    Serial.println("Unexpected packet size; dumping hex:");
    static uint8_t buf[256];
    int toRead = min(packetSize, (int)sizeof(buf));
    int n = LoRa.readBytes(buf, toRead);
    while (LoRa.available()) LoRa.read(); // drain
    hexDump(buf, n);
  }
}
