// ===== LoRa Receiver (Enhanced) =====
#include <SPI.h>
#include <LoRa.h>
// #include <WiFi.h>
// #include <PubSubClient.h>
#ifndef LORA_NSS_PIN
  #define LORA_NSS_PIN LORA_SS   // or replace with `ss` if that‚Äôs your symbol
#endif
// ------------ Config ------------
#define LORA_SS    5
#define LORA_RST   13
#define LORA_DIO0  25
#define LORA_FREQ  923E6
#define LORA_SYNC  0xF3

#define DEBUG 1
#if DEBUG
  #define DBG(...)  Serial.println(__VA_ARGS__)
#else
  #define DBG(...)
#endif

// If your sender uses packed structs, match packing:
#pragma pack(push,1)
struct LoRaData {
  uint8_t  packetCounter;
  double   latitude;
  double   longitude;
  float    altitude;
  float    speed;
  uint8_t  satellites;
  char     timeUTC[20];  // enough for "YYYY/MM/DD,HH:MM:SS" + '\0'
  bool     doorValue
};
#pragma pack(pop)


LoRaData receivedData;

// // MQTT bits if you re-enable later
// const char* ssid = "alyaone";
// const char* password = "apayalupa";
// const char* mqtt_server = "172.20.10.5";
// const int   mqtt_port   = 1883;
// WiFiClient espClient;
// PubSubClient client(espClient);

// ------------ Helpers ------------
static void hexDump(const uint8_t* buf, int len) {
  for (int i = 0; i < len; ++i) {
    if (i % 16 == 0) Serial.println();
    if (buf[i] < 16) Serial.print('0');
    Serial.print(buf[i], HEX);
    Serial.print(' ');
  }
  Serial.println();
}
static uint8_t sx127xReadReg(uint8_t addr) {
  SPI.beginTransaction(SPISettings(8000000, MSBFIRST, SPI_MODE0));
  digitalWrite(LORA_NSS_PIN, LOW);
  SPI.transfer(addr & 0x7F);
  uint8_t v = SPI.transfer(0x00);
  digitalWrite(LORA_NSS_PIN, HIGH);
  SPI.endTransaction();
  return v;
}

static void sx127xWriteReg(uint8_t addr, uint8_t val) {
  SPI.beginTransaction(SPISettings(8000000, MSBFIRST, SPI_MODE0));
  digitalWrite(LORA_NSS_PIN, LOW);
  SPI.transfer(addr | 0x80);
  SPI.transfer(val);
  digitalWrite(LORA_NSS_PIN, HIGH);
  SPI.endTransaction();
}

static void loraSetLDRO(bool on) {               // RegModemConfig3 bit3
  uint8_t r = sx127xReadReg(0x26);
  r = on ? (r |  0b00001000) : (r & ~0b00001000);
  sx127xWriteReg(0x26, r);
}

static void loraSetLnaBoostHF(bool on) {         // RegLna bits7:6 = 11
  uint8_t r = sx127xReadReg(0x0C) & 0x3F;
  if (on) r |= 0xC0;
  sx127xWriteReg(0x0C, r);
}

void setup() {
  Serial.begin(115200);
  delay(300);
  Serial.println("\nüì° LoRa Receiver Node Starting...");

  LoRa.setPins(LORA_SS, LORA_RST, LORA_DIO0);

  int tries = 0;
  while (!LoRa.begin(LORA_FREQ)) {
    Serial.println("LoRa init failed. Retrying...");
    delay(400);
    if (++tries > 20) {
      Serial.println("LoRa init giving up. Check wiring/freq.");
      return; // bail out if radio never comes up
    }
  }

  // ---- Match the transmitter‚Äôs settings ----
  // validate packets with CRC

  LoRa.setSpreadingFactor(12);     // SF7..12 (higher = longer range, lower data rate)
  LoRa.setSignalBandwidth(125E3); // 7.8k..500k (narrower = better sensitivity, lower data rate)
  LoRa.setCodingRate4(8);         // 4/5..4/8 (higher = more robust, lower throughput)
  LoRa.setPreambleLength(12);      // default is 8, can increase for noisy links
  LoRa.setSyncWord(0x34);         // must match RX
  LoRa.enableCrc();               // must match RX
  LoRa.setGain(0);                // 0 = AGC ON (auto LNA gain control)
  loraSetLDRO(true);              // LDRO ON (needed for SF11/SF12 at narrow BW)
  loraSetLnaBoostHF(true);        // LNA Boost HF ON (extra sensitivity, more current)


  // Optional RX-side tuning (leave as-is if unsure):
  // LoRa.setGain(0);                   // 0 = AGC (default). 1..6 = manual LNA gain.

  Serial.println("LoRa Initialized OK!");
  Serial.println("Ready to receive packets.");

  // If you use onReceive(callback), enable continuous RX:
  // LoRa.onReceive(onLoRaPacket);
  // LoRa.receive();

  // Otherwise, if you poll with LoRa.parsePacket() in loop(), no extra call needed.
}


void loop() {
  // if (!client.connected()) { /* reconnect MQTT */ }
  // client.loop();

  int packetSize = LoRa.parsePacket();
  if (!packetSize) {
    delay(2);
    return;
  }

  // Show basic RF stats
  int rssi = LoRa.packetRssi();
  float snr = LoRa.packetSnr();
  Serial.println("\n‚úÖ LoRa packet detected.");
  Serial.print("Packet bytes: "); Serial.println(packetSize);
  Serial.print("RSSI: "); Serial.print(rssi);
  Serial.print(" dBm | SNR: "); Serial.print(snr, 1); Serial.println(" dB");

  // If size matches our struct, read directly; else show hex dump
  if (packetSize == (int)sizeof(LoRaData)) {
    memset(&receivedData, 0, sizeof(receivedData)); // avoid stale bytes
    int n = LoRa.readBytes((uint8_t*)&receivedData, sizeof(receivedData));
    // Drain any leftover (should be none if sizes match)
    while (LoRa.available()) LoRa.read();

    if (n == sizeof(LoRaData)) {
      // Ensure C-string termination (defensive)
      receivedData.timeUTC[sizeof(receivedData.timeUTC) - 1] = '\0';

      Serial.print("\n------ Receive Data Packet #");
      Serial.print(receivedData.packetCounter);
      Serial.println(" ------");
      Serial.print("Lat: ");  Serial.println(receivedData.latitude, 6);
      Serial.print("Lon: ");  Serial.println(receivedData.longitude, 6);
      Serial.print("Alt: ");  Serial.print(receivedData.altitude, 2); Serial.println(" m");
      Serial.print("Spd: ");  Serial.print(receivedData.speed, 2);    Serial.println(" km/h");
      Serial.print("Sats: "); Serial.println(receivedData.satellites);
      Serial.print("Time: "); Serial.println(receivedData.timeUTC);
      Serial.print("Door: "); 
      if (dataToSend.doorValue) {
      Serial.println("Switch Closed");
    } else {
      Serial.println("Switch Open");
    }
      Serial.println("---------------------------------------------");

      // // Build JSON (compact)
      // String payload = "{";
      // payload += "\"packetCounter\":" + String(receivedData.packetCounter) + ",";
      // payload += "\"latitude\":"      + String(receivedData.latitude, 6) + ",";
      // payload += "\"longitude\":"     + String(receivedData.longitude, 6) + ",";
      // payload += "\"altitude\":"      + String(receivedData.altitude, 2) + ",";
      // payload += "\"speed\":"         + String(receivedData.speed, 2) + ",";
      // payload += "\"satellites\":"    + String(receivedData.satellites) + ",";
      // payload += "\"timeUTC\":\""     + String(receivedData.timeUTC) + "\",";
      // payload += "\"rssi\":"          + String(rssi) + ",";
      // payload += "\"snr\":"           + String(snr,1);
      // payload += "}";

      // Serial.println("JSON:");
      // Serial.println(payload);

      // // Publish to MQTT (uncomment when ready)
      // if (client.publish("supplychain/containers", payload.c_str())) {
      //   Serial.println("üì§ MQTT published");
      // } else {
      //   Serial.println("‚ùå MQTT publish failed");
      // }

    } else {
      Serial.println("Error: struct read incomplete. Dumping raw:");
      // read any remaining bytes (already drained above) then print what we got
      hexDump((const uint8_t*)&receivedData, n);
    }

  } else {
    // Unexpected length ‚Äî read and hexdump for debugging
    Serial.println("Unexpected packet size; dumping hex:");
    static uint8_t buf[256];
    int toRead = min(packetSize, (int)sizeof(buf));
    int n = LoRa.readBytes(buf, toRead);
    while (LoRa.available()) LoRa.read(); // drain
    hexDump(buf, n);
  }
}
