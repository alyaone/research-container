// ===== LoRa Receiver (Enhanced) =====
#include <SPI.h>
#include <LoRa.h>
// #include <WiFi.h>
// #include <PubSubClient.h>

// ------------ Config ------------
#define LORA_SS    5
#define LORA_RST   13
#define LORA_DIO0  25
#define LORA_FREQ  865.0625E6
#define LORA_SYNC  0xF3

#define DEBUG 1
#if DEBUG
  #define DBG(...)  Serial.println(__VA_ARGS__)
#else
  #define DBG(...)
#endif

// If your sender uses packed structs, match packing:
#pragma pack(push,1)
struct LoRaData {
  uint8_t  packetCounter;
  double   latitude;
  double   longitude;
  float    altitude;
  float    speed;
  uint8_t  satellites;
  char     timeUTC[20];  // enough for "YYYY/MM/DD,HH:MM:SS" + '\0'
};
#pragma pack(pop)


LoRaData receivedData;

// // MQTT bits if you re-enable later
// const char* ssid = "alyaone";
// const char* password = "apayalupa";
// const char* mqtt_server = "172.20.10.5";
// const int   mqtt_port   = 1883;
// WiFiClient espClient;
// PubSubClient client(espClient);

// ------------ Helpers ------------
static void hexDump(const uint8_t* buf, int len) {
  for (int i = 0; i < len; ++i) {
    if (i % 16 == 0) Serial.println();
    if (buf[i] < 16) Serial.print('0');
    Serial.print(buf[i], HEX);
    Serial.print(' ');
  }
  Serial.println();
}

void setup() {
  Serial.begin(115200);
  delay(300);
  Serial.println("\nüì° LoRa Receiver Node Starting...");

  LoRa.setPins(LORA_SS, LORA_RST, LORA_DIO0);

  int tries = 0;
  while (!LoRa.begin(LORA_FREQ)) {
    Serial.println("LoRa init failed. Retrying...");
    delay(400);
    if (++tries > 20) {
      Serial.println("LoRa init giving up. Check wiring/freq.");
      break;
    }
  }
  LoRa.setSyncWord(LORA_SYNC);
  // Optional radio tuning (must match sender if you change them)
  // LoRa.setSpreadingFactor(7);   // 6‚Äì12
  // LoRa.setSignalBandwidth(125E3); // 7.8‚Äì500 kHz
  // LoRa.setCodingRate4(5);       // 5‚Äì8

  Serial.println("LoRa Initialized OK!");
  Serial.println("Ready to receive packets.");

  // // WiFi / MQTT (optional)
  // WiFi.begin(ssid, password);
  // while (WiFi.status() != WL_CONNECTED) { delay(300); Serial.print('.'); }
  // Serial.println("\nWiFi connected");
  // client.setServer(mqtt_server, mqtt_port);
}

void loop() {
  // if (!client.connected()) { /* reconnect MQTT */ }
  // client.loop();

  int packetSize = LoRa.parsePacket();
  if (!packetSize) {
    delay(2);
    return;
  }

  // Show basic RF stats
  int rssi = LoRa.packetRssi();
  float snr = LoRa.packetSnr();
  Serial.println("\n‚úÖ LoRa packet detected.");
  Serial.print("Packet bytes: "); Serial.println(packetSize);
  Serial.print("RSSI: "); Serial.print(rssi);
  Serial.print(" dBm | SNR: "); Serial.print(snr, 1); Serial.println(" dB");

  // If size matches our struct, read directly; else show hex dump
  if (packetSize == (int)sizeof(LoRaData)) {
    memset(&receivedData, 0, sizeof(receivedData)); // avoid stale bytes
    int n = LoRa.readBytes((uint8_t*)&receivedData, sizeof(receivedData));
    // Drain any leftover (should be none if sizes match)
    while (LoRa.available()) LoRa.read();

    if (n == sizeof(LoRaData)) {
      // Ensure C-string termination (defensive)
      receivedData.timeUTC[sizeof(receivedData.timeUTC) - 1] = '\0';

      Serial.print("\n------ Receive Data Packet #");
      Serial.print(receivedData.packetCounter);
      Serial.println(" ------");
      Serial.print("Lat: ");  Serial.println(receivedData.latitude, 6);
      Serial.print("Lon: ");  Serial.println(receivedData.longitude, 6);
      Serial.print("Alt: ");  Serial.print(receivedData.altitude, 2); Serial.println(" m");
      Serial.print("Spd: ");  Serial.print(receivedData.speed, 2);    Serial.println(" km/h");
      Serial.print("Sats: "); Serial.println(receivedData.satellites);
      Serial.print("Time: "); Serial.println(receivedData.timeUTC);
      Serial.println("---------------------------------------------");

      // // Build JSON (compact)
      // String payload = "{";
      // payload += "\"packetCounter\":" + String(receivedData.packetCounter) + ",";
      // payload += "\"latitude\":"      + String(receivedData.latitude, 6) + ",";
      // payload += "\"longitude\":"     + String(receivedData.longitude, 6) + ",";
      // payload += "\"altitude\":"      + String(receivedData.altitude, 2) + ",";
      // payload += "\"speed\":"         + String(receivedData.speed, 2) + ",";
      // payload += "\"satellites\":"    + String(receivedData.satellites) + ",";
      // payload += "\"timeUTC\":\""     + String(receivedData.timeUTC) + "\",";
      // payload += "\"rssi\":"          + String(rssi) + ",";
      // payload += "\"snr\":"           + String(snr,1);
      // payload += "}";

      // Serial.println("JSON:");
      // Serial.println(payload);

      // // Publish to MQTT (uncomment when ready)
      // if (client.publish("supplychain/containers", payload.c_str())) {
      //   Serial.println("üì§ MQTT published");
      // } else {
      //   Serial.println("‚ùå MQTT publish failed");
      // }

    } else {
      Serial.println("Error: struct read incomplete. Dumping raw:");
      // read any remaining bytes (already drained above) then print what we got
      hexDump((const uint8_t*)&receivedData, n);
    }

  } else {
    // Unexpected length ‚Äî read and hexdump for debugging
    Serial.println("Unexpected packet size; dumping hex:");
    static uint8_t buf[256];
    int toRead = min(packetSize, (int)sizeof(buf));
    int n = LoRa.readBytes(buf, toRead);
    while (LoRa.available()) LoRa.read(); // drain
    hexDump(buf, n);
  }
}
