// ===== LoRa Receiver ‚Üí ThingSpeak MQTT =====
#include <SPI.h>
#include <LoRa.h>
#include <WiFi.h>
#include <PubSubClient.h>

// ------------ LoRa Config ------------
#define LORA_SS    5
#define LORA_RST   13
#define LORA_DIO0  25
#define LORA_FREQ  865.0625E6
#define LORA_SYNC  0xF3

#define DEBUG 1
#if DEBUG
  #define DBG(...)  Serial.println(__VA_ARGS__)
#else
  #define DBG(...)
#endif

#pragma pack(push,1)
struct LoRaData {
  uint8_t  packetCounter;
  double   latitude;
  double   longitude;
  float    altitude;
  float    speed;         // km/h
  uint8_t  satellites;
  char     timeUTC[20];   // "YYYY/MM/DD,HH:MM:SS"
};
#pragma pack(pop)

LoRaData receivedData;

// ------------ WiFi & ThingSpeak MQTT ------------
const char* WIFI_SSID     = "YOUR_WIFI";
const char* WIFI_PASS     = "YOUR_PASS";

const char* TS_BROKER     = "mqtt3.thingspeak.com";
const uint16_t TS_PORT    = 1883;                 // use 8883 with WiFiClientSecure for TLS
const char* TS_CLIENT_ID  = "DTAsFA82DDMrCxIsLhkONx4";
const char* TS_USERNAME   = "DTAsFA82DDMrCxIsLhkONx4";
const char* TS_PASSWORD   = "7tuSFx6IFxHGB8wg058AEz4n";
const char* TS_CHANNEL_ID = "3095305";    // e.g., "1234567"

// Topic per ThingSpeak docs: channels/<channelID>/publish
String tsTopic = String("channels/") + TS_CHANNEL_ID + "/publish";

// MQTT client
WiFiClient wifiClient;
PubSubClient mqtt(wifiClient);

// ------------ Helpers ------------
static void hexDump(const uint8_t* buf, int len) {
  for (int i = 0; i < len; ++i) {
    if (i % 16 == 0) Serial.println();
    if (buf[i] < 16) Serial.print('0');
    Serial.print(buf[i], HEX);
    Serial.print(' ');
  }
  Serial.println();
}

static void connectWiFi() {
  if (WiFi.status() == WL_CONNECTED) return;
  Serial.print("Connecting WiFi ");
  Serial.print(WIFI_SSID);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  int tries = 0;
  while (WiFi.status() != WL_CONNECTED) {
    delay(300);
    Serial.print('.');
    if (++tries > 60) { Serial.println("\nWiFi timeout"); break; }
  }
  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("\nWiFi OK. IP: "); Serial.println(WiFi.localIP());
  }
}

static void connectMQTT() {
  mqtt.setServer(TS_BROKER, TS_PORT); // QoS 0 only on ThingSpeak
  while (!mqtt.connected() && WiFi.status() == WL_CONNECTED) {
    Serial.print("Connecting MQTT to ThingSpeak...");
    // ThingSpeak requires: clientId, username, password (from MQTT Device)
    if (mqtt.connect(TS_CLIENT_ID, TS_USERNAME, TS_PASSWORD)) {
      Serial.println(" connected.");
    } else {
      Serial.print(" failed, rc="); Serial.print(mqtt.state());
      Serial.println(" retry in 2s");
      delay(2000);
    }
  }
}

void setup() {
  Serial.begin(115200);
  delay(300);
  Serial.println("\nüì° LoRa Receiver ‚Üí ThingSpeak MQTT Starting...");

  // LoRa init
  LoRa.setPins(LORA_SS, LORA_RST, LORA_DIO0);
  int tries = 0;
  while (!LoRa.begin(LORA_FREQ)) {
    Serial.println("LoRa init failed. Retrying...");
    delay(400);
    if (++tries > 20) {
      Serial.println("LoRa init giving up. Check wiring/freq.");
      break;
    }
  }
  LoRa.setSyncWord(LORA_SYNC);
  Serial.println("LoRa Initialized. Ready to receive.");

  // WiFi & MQTT
  connectWiFi();
  connectMQTT();
}

void loop() {
  if (WiFi.status() != WL_CONNECTED) connectWiFi();
  if (!mqtt.connected()) connectMQTT();
  mqtt.loop();  // keeps connection alive

  int packetSize = LoRa.parsePacket();
  if (!packetSize) { delay(2); return; }

  int rssi = LoRa.packetRssi();
  float snr = LoRa.packetSnr();
  Serial.println("\n‚úÖ LoRa packet detected.");
  Serial.print("Packet bytes: "); Serial.println(packetSize);
  Serial.print("RSSI: "); Serial.print(rssi);
  Serial.print(" dBm | SNR: "); Serial.print(snr, 1); Serial.println(" dB");

  if (packetSize == (int)sizeof(LoRaData)) {
    memset(&receivedData, 0, sizeof(receivedData));
    int n = LoRa.readBytes((uint8_t*)&receivedData, sizeof(receivedData));
    while (LoRa.available()) LoRa.read();

    if (n == sizeof(LoRaData)) {
      receivedData.timeUTC[sizeof(receivedData.timeUTC) - 1] = '\0';

      Serial.print("\n------ Receive Data Packet #");
      Serial.print(receivedData.packetCounter);
      Serial.println(" ------");
      Serial.print("Lat: ");  Serial.println(receivedData.latitude, 6);
      Serial.print("Lon: ");  Serial.println(receivedData.longitude, 6);
      Serial.print("Alt: ");  Serial.print(receivedData.altitude, 2); Serial.println(" m");
      Serial.print("Spd: ");  Serial.print(receivedData.speed, 2);    Serial.println(" km/h");
      Serial.print("Sats: "); Serial.println(receivedData.satellites);
      Serial.print("Time: "); Serial.println(receivedData.timeUTC);
      Serial.println("---------------------------------------------");

      // ---- Build ThingSpeak payload (URL-encoded key=value pairs)
      // Map: field1 = speed, field2 = sats, field3 = RSSI, field4 = SNR*10, lat/long/elevation via special keys
      // NOTE: ThingSpeak supports up to 8 fields; QoS must be 0.
      String payload;
      payload.reserve(160);
      payload  = "field1=" + String(receivedData.speed, 2);
      payload += "&field2=" + String((int)receivedData.satellites);
      payload += "&field3=" + String(rssi);
      payload += "&field4=" + String((int)(snr * 10));   // store SNR x10 as integer
      payload += "&lat=" + String(receivedData.latitude, 6);
      payload += "&long=" + String(receivedData.longitude, 6);
      payload += "&elevation=" + String(receivedData.altitude, 2);
      payload += "&status=LoRa%20OK%20pkt%23" + String(receivedData.packetCounter);

      // ---- Publish (ThingSpeak requires QoS 0; PubSubClient uses QoS 0)
      bool ok = mqtt.publish(tsTopic.c_str(), payload.c_str());
      if (ok) {
        Serial.println("üì§ ThingSpeak MQTT published:");
        Serial.println(payload);
      } else {
        Serial.println("‚ùå ThingSpeak MQTT publish failed");
      }

    } else {
      Serial.println("Error: struct read incomplete. Dumping raw:");
      hexDump((const uint8_t*)&receivedData, n);
    }
  } else {
    Serial.println("Unexpected packet size; dumping hex:");
    static uint8_t buf[256];
    int toRead = min(packetSize, (int)sizeof(buf));
    int n = LoRa.readBytes(buf, toRead);
    while (LoRa.available()) LoRa.read();
    hexDump(buf, n);
  }
}
